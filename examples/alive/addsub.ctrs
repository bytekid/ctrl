THEORY bitvectors;
LOGIC QF_UFBV;
SOLVER external;
SIGNATURE Xor, add_i1, lshr, sub_nuw, zext_i1, select, sub, shl_nsw, sub_nsw, add_nuw, add, shl_nuw, mul, sub_i1, add_nsw, sext, sdiv_i9, sext_i1, Or, trunc, And, sdiv, zext, shl, ashr,  !BITVECTOR;

RULES
    add(add(Xor(Or(Z, C2), C1), #x00000001), RHS) -> sub(RHS, And(Z, C1))  [ (C2 = ~(C1))] ;
    add(add(Xor(And(Z, C1), C1), #x00000001), RHS) -> sub(RHS, Or(Z, ~(C1)));
    add(Xor(And(Z, C2), C1), RHS) -> sub(RHS, Or(Z, ~(C2)))  [ ((countTrailingZeros(C1) = #x00000000) /\ (C1 = (C2 +i #x00000001)))] ;
    add(x, C) -> Xor(x, C)  [ isSignBit(C)] ;
    add(zext_i1(a), b) -> select(a, add(b, #x00000001), b);
    add(Xor(Y, C2), C1) -> ashr(shl(Y, CL0), CL0)  [ (((width(C1) -i (width(C1) -i (log2_th(C2) -i #x00000001))) = CL0) /\ ((C1 = neg(C2)) /\ (isPowerOf2(C2) /\ not(MaskedValueIsZero(C2, (#xffffffff << (width(C1) -i (width(C1) -i (log2_th(C2) -i #x00000001)))))))))] ;
    add(Xor(Y, C2), C1) -> ashr(shl(Y, CL0), CL0)  [ (((width(C1) -i (log2_th(C1) -i #x00000001)) = CL0) /\ ((C2 = neg(C1)) /\ (isPowerOf2(C1) /\ MaskedValueIsZero(Y, (#xffffffff << (log2_th(C1) +i #x00000001))))))] ;
    add(Xor(Y, C2), C1) -> ashr(shl(Y, CL0), CL0)  [ (((width(C2) -i (log2_th(C2) -i #x00000001)) = CL0) /\ ((C2 = neg(C1)) /\ (isPowerOf2(C2) /\ MaskedValueIsZero(Y, (#xffffffff << (log2_th(C2) +i #x00000001))))))] ;
    add(Xor(Y, C2), C1) -> sub(CL0, Y)  [ (((C1 +i C2) = CL0) /\ (hasOneUse /\ (isPowerOf2((C2 +i #x00000001)) /\ ((C2 | computeKnownZeroBits(Y)) = #xffffffff))))] ;
    add(Xor(a, C1), C2) -> add(a, CL0)  [ (((C1 ^ C2) = CL0) /\ isSignBit(C1))] ;
    add_i1(x, y) -> Xor(x, y);
    add(b, b) -> shl(b, #x00000001);
    add_nsw(b, b) -> shl_nsw(b, #x00000001);
    add_nuw(b, b) -> shl_nuw(b, #x00000001);
    add(sub(#x00000000, a), b) -> sub(b, a);
    add(sub(#x00000000, a), sub(#x00000000, b)) -> sub(#x00000000, add(a, b));
    add(a, sub(#x00000000, b)) -> sub(a, b);
    add(x, y) -> Or(x, y)  [ ((computeKnownZeroBits(x) | computeKnownZeroBits(y)) = #xffffffff)] ;
    add(Xor(x, #xffffffff), C) -> sub(CL0, x)  [ ((C -i #x00000001) = CL0)] ;
    add(And(x, C2), C1) -> And(add(x, C1), C2)  [ (hasOneUse /\ (~(((C1 & neg(C1)) -i #x00000001)) = (~(((C1 & neg(C1)) -i #x00000001)) & C2)))] ;
    add(select(x, #x00000000, sub(n, a)), a) -> select(x, a, n)  [ hasOneUse] ;
    add(select(x, sub(n, a), #x00000000), a) -> select(x, n, a)  [ hasOneUse] ;
    add(sext(x), C) -> sext(add_nsw(x, trunc(C)))  [ (hasOneUse /\ (WillNotOverflowSignedAdd(x, trunc_th(C)) /\ ((C & (#xffffffff << (width(x) -i #x00000001))) = #x00000000)))] ;
    add(sext(x), sext(y)) -> sext(add_nsw(x, y))  [ ((hasOneUse \/ hasOneUse) /\ WillNotOverflowSignedAdd(x, y))] ;
    add(And(a, b), Xor(a, b)) -> Or(a, b);
    add(And(a, b), Or(a, b)) -> add(a, b);
    add_nsw(And(a, b), Or(a, b)) -> add_nsw(a, b);
    add_nuw(And(a, b), Or(a, b)) -> add_nuw(a, b);
    add(lhs, rhs) -> add_nsw(lhs, rhs)  [ WillNotOverflowSignedAdd(lhs, rhs)] ;
    add(lhs, rhs) -> add_nuw(lhs, rhs)  [ WillNotOverflowUnsignedAdd(lhs, rhs)] ;
    sub(x, sub(#x00000000, a)) -> add(x, a);
    sub(x, C) -> add(x, neg(C));
    sub_nsw(x, sub_nsw(#x00000000, a)) -> add_nsw(x, a);
    sub_nsw(x, C) -> add_nsw(x, neg(C))  [ (C != (#x00000001 << (width(C) -i #x00000001)))] ;
    sub_i1(x, y) -> Xor(x, y);
    sub(#xffffffff, a) -> Xor(a, #xffffffff);
    sub(C, Xor(x, #xffffffff)) -> add(x, CL0)  [ ((C +i #x00000001) = CL0)] ;
    sub(C, add(X, C2)) -> sub(CL0, X)  [ ((C -i C2) = CL0)] ;
    sub(#x00000000, zext_i1(X)) -> sext(X);
    sub(#x00000000, sext_i1(X)) -> zext(X);
    sub(#x00000000, lshr(x, C)) -> ashr(x, C)  [ (C = (width(lshr_th(x, C)) -i #x00000001))] ;
    sub(#x00000000, ashr(x, C)) -> lshr(x, C)  [ (C = (width(ashr_th(x, C)) -i #x00000001))] ;
    sub(X, add(X, Y)) -> sub(#x00000000, Y);
    sub(sub(X, Y), X) -> sub(#x00000000, Y);
    sub(Or(A, B), Xor(A, B)) -> And(A, B);
    sub(Or(Y, Op1), Op1) -> And(Xor(Op1, #xffffffff), Y)  [ hasOneUse] ;
    sub(X, sub(Y, Z)) -> add(X, sub(Z, Y))  [ hasOneUse] ;
    sub(X, And(X, Y)) -> And(X, Xor(Y, #xffffffff))  [ hasOneUse] ;
    sub(#x00000000, sdiv_i9(X, C)) -> sdiv(X, neg(C))  [ (hasOneUse /\ ((C != #x00000001) /\ (C != (#x00000001 << (width(C) -i #x00000001)))))] ;
    sub(#x00000000, shl(C, Y)) -> shl(neg(C), Y)  [ hasOneUse] ;
    sub(#x00000000, shl(sub(#x00000000, X), Y)) -> shl(X, Y)  [ hasOneUse] ;
    sub(X, mul(A, sub(#x00000000, B))) -> add(X, mul(A, B))  [ hasOneUse] ;
    sub(X, mul(A, C)) -> add(X, mul(A, neg(C)))  [ hasOneUse] ;
    sub(A, B) -> sub_nsw(A, B)  [ WillNotOverflowSignedSub(A, B)] ;
    sub(A, B) -> sub_nuw(A, B)  [ WillNotOverflowUnsignedSub(A, B)] ;
    add_i1(X0, X1) -> add(X0, X1);
    sub_nsw(X0, X1) -> sub(X0, X1);
    sub_i1(X0, X1) -> sub(X0, X1);
    sext_i1(X0) -> sext(X0);
    zext_i1(X0) -> zext(X0);
    shl_nuw(X0, X1) -> shl(X0, X1);
    add_nuw(X0, X1) -> add(X0, X1);
    add_nsw(X0, X1) -> add(X0, X1);
    shl_nsw(X0, X1) -> shl(X0, X1);
    sub_nuw(X0, X1) -> sub(X0, X1);
    sdiv_i9(X0, X1) -> sdiv(X0, X1);

NON-STANDARD IRREGULAR

QUERY loops
