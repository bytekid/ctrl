INCLUDE ints ;

DECLARE
  !BITVECTOR : (BitVec _)                             ;
  !=          : (BitVec _) * (BitVec _) => Bool (infix 70)    ;
  i<=         : (BitVec _) * (BitVec _) => Bool (infix 70)    ;
  i>=         : (BitVec _) * (BitVec _) => Bool (infix 70)    ;
  i<          : (BitVec _) * (BitVec _) => Bool (infix 70)    ;
  i>          : (BitVec _) * (BitVec _) => Bool (infix 70)    ;
  u<=         : (BitVec _) * (BitVec _) => Bool (infix 70)    ;
  u>=         : (BitVec _) * (BitVec _) => Bool (infix 70)    ;
  u<          : (BitVec _) * (BitVec _) => Bool (infix 70)    ;
  u>          : (BitVec _) * (BitVec _) => Bool (infix 70)    ;

  ~           : (BitVec _) => (BitVec _);
  &           : (BitVec _) * (BitVec _) => (BitVec _) (l-infix 150) ;
  |           : (BitVec _) * (BitVec _) => (BitVec _) (l-infix 100) ;
  ^           : (BitVec _) * (BitVec _) => (BitVec _) (l-infix 100) ;

  neg         : (BitVec _) => (BitVec _);
  +i          : (BitVec _) * (BitVec _) => (BitVec _) (l-infix 100);
  -i          : (BitVec _) * (BitVec _) => (BitVec _) (l-infix 100);
  *i          : (BitVec _) * (BitVec _) => (BitVec _) (l-infix 150);
  /           : (BitVec _) * (BitVec _) => (BitVec _) (l-infix 150);
  /u           : (BitVec _) * (BitVec _) => (BitVec _) (l-infix 150);
  %           : (BitVec _) * (BitVec _) => (BitVec _) (l-infix 150);
  %u           : (BitVec _) * (BitVec _) => (BitVec _) (l-infix 150);
  <<          : (BitVec _) * (BitVec _) => (BitVec _) (r-infix 100);
  u>>          : (BitVec _) * (BitVec _) => (BitVec _) (r-infix 100);
  >>          : (BitVec _) * (BitVec _) => (BitVec _) (r-infix 100);

  #x00000000: (BitVec _);
  #x00000001: (BitVec _);
  #x00000002: (BitVec _);
  #x00000003: (BitVec _);
  #xfffffffe: (BitVec _);
  #xffffffff: (BitVec _);

  Abs_th : (BitVec _) => (BitVec _) ;
  ashr_th : (BitVec _) * (BitVec _) => (BitVec _);
  computeKnownZeroBits : (BitVec _) => (BitVec _);
  computeNumSignBits : (BitVec _) => (BitVec _);
  countLeadingZeros : (BitVec _) => (BitVec _);
  countTrailingZeros : (BitVec _) => (BitVec _);
  hasOneUse : Bool;
  isPowerOf2 : (BitVec _) => Bool;
  isPowerOf2OrZero : (BitVec _) => Bool;
  isShiftedMask : (BitVec _) => Bool;
  isSignBit : (BitVec _) => Bool;
  lshr_th : (BitVec _) * (BitVec _) => (BitVec _);
  log2_th : (BitVec _) => (BitVec _);
  MaskedValueIsZero : (BitVec _) * (BitVec _) => Bool;
  max_th          : (BitVec _) * (BitVec _) => (BitVec _);
  sext_th : (BitVec _) => (BitVec _);
  sexti15 : (BitVec _) => (BitVec _);
  trunc_th : (BitVec _) => (BitVec _);
  width : (BitVec _) => (BitVec _);
  WillNotOverflowSignedAdd : (BitVec _) * (BitVec _) => Bool;
  WillNotOverflowSignedMul : (BitVec _) * (BitVec _) => Bool;
  WillNotOverflowSignedSub : (BitVec _) * (BitVec _) => Bool;
  WillNotOverflowUnsignedAdd : (BitVec _) * (BitVec _) => Bool;
  WillNotOverflowUnsignedMul : (BitVec _) * (BitVec _) => Bool;
  WillNotOverflowUnsignedShl : (BitVec _) * (BitVec _) => Bool;
  WillNotOverflowUnsignedSub : (BitVec _) * (BitVec _) => Bool;
  zext_th : (BitVec _) => (BitVec _);
  zexti15 : (BitVec _) => (BitVec _);
  ZExtOrTrunc_i11 : (BitVec _) => (BitVec _);



WELLFOUNDED i>, u> ;

SMT-RENAMINGS
  i< 		-> bvslt;
  i<=  	-> bvsle;
  i> 		-> bvsgt;
  i>=  	-> bvsge;
  u< 		-> bvult;
  u<=  	-> bvule;
  u> 		-> bvugt;
  u>=  	-> bvuge;

  +i 		-> bvadd;
  -i  	-> bvsub;
  *i 		-> bvmul;
  / 		-> bvsdiv;
  /u 		-> bvudiv;
  % 		-> bvsrem;
  %u 		-> bvurem;

  << 		-> bvshl;
  u>> 	-> bvlshr;
  >> 	  -> bvashr;

  ~  	-> bvnot;
  &  	-> bvand;
  |  	-> bvor;
  ^  	-> bvxor;

  hasOneUse -> true;

SMT-TRANSLATIONS
  !=(x, y) -> (not (= x y));
  Abs_th(x) -> (ite (bvsge x #x00000000) x (bvneg x));
  ashr_th(x,y) -> (bvashr x y);           /* not in SMT-LIB but accepted by Z3 */
  computeKnownZeroBits(x) -> ((_ zero_extend 0) x); /* worst case: everything is known */
  computeNumSignBits(x) -> ((_ zero_extend 0) x); /* worst case: everything is known */
  countLeadingZeros(x) -> ((_ zero_extend 0) x); /* worst case: everything is known */
  countTrailingZeros(x) -> ((_ zero_extend 0) x); /* worst case: everything is known */
  isPowerOf2(x) -> (and (= (bvand x (bvsub x #x00000001)) #x00000000) (not (= x #x00000000))) ;
  isPowerOf2OrZero(x) -> (= (bvand x (bvsub x #x00000001)) #x00000000) ;
  isShiftedMask(x) -> (let ((vv (bvor (bvsub x #x00000001) x))) (and (not (= vv #x00000000)) (= #x00000000 (bvand vv (bvadd vv #x00000001)))));
  isSignBit(x) -> (= (bvlshr x #x0000001f) #x00000001);
  log2_th(x) -> (ite (= x #x00000001) #x00000000 #x00000000);
  lshr_th(x,y) -> (bvlshr x y);
  MaskedValueIsZero(x,y) -> (= (bvand x y) #x00000000);
  neg(x) -> (bvneg x) ;
  WillNotOverflowSignedAdd(x,y) -> (= (bvadd ((_ sign_extend 1) x) ((_ sign_extend 1) y)) ((_ sign_extend 1) (bvadd x y)));
  WillNotOverflowUnsignedAdd(x,y) -> (= (bvadd ((_ zero_extend 1) x) ((_ zero_extend 1) y)) ((_ zero_extend 1) (bvadd x y)));
  WillNotOverflowSignedSub(x,y) -> (= (bvsub ((_ sign_extend 1) x) ((_ sign_extend 1) y)) ((_ sign_extend 1) (bvsub x y)));
  WillNotOverflowUnsignedSub(x,y) -> (= (bvsub ((_ zero_extend 1) x) ((_ zero_extend 1) y)) ((_ zero_extend 1) (bvsub x y)));
  WillNotOverflowSignedMul(x,y) -> (= (bvmul ((_ sign_extend 32) x) ((_ sign_extend 32) y)) ((_ sign_extend 32) (bvmul x y)));
  WillNotOverflowUnsignedMul(x,y) -> (= (bvmul ((_ zero_extend 32) x) ((_ zero_extend 32) y)) ((_ zero_extend 32) (bvmul x y)));
  WillNotOverflowUnsignedShl(x,y) -> (= x (bvlshr (bvshl x y) y));

  sext_i1(x) -> ((_ sign_extend 31) x);
  zext_i1(x) -> ((_ zero_extend 31) x);
  sexti11(x) -> ((_ sign_extend 21) x);
  zexti11(x) -> ((_ zero_extend 21) x);
  sexti15(x) -> ((_ sign_extend 21) x);
  zexti15(x) -> ((_ zero_extend 21) x);
  sext_th(x) -> ((_ sign_extend 0) x);
  zext_th(x) -> ((_ zero_extend 0) x);

  trunc_th(x) -> ((_ zero_extend 0) x) ; /* FIXME: how to deal with bitvectors of different sizes? */
  width(x) -> ((_ zero_extend 0) #x00000020); /* FIXME: how to deal with bitvectors of different sizes? */
  