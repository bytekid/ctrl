INCLUDE ints ;

DECLARE
  !BITVECTOR : BitVec                             ;
  !=          : BitVec * BitVec => Bool (infix 70)    ;
  i<=         : BitVec * BitVec => Bool (infix 70)    ;
  i>=         : BitVec * BitVec => Bool (infix 70)    ;
  i<          : BitVec * BitVec => Bool (infix 70)    ;
  i>          : BitVec * BitVec => Bool (infix 70)    ;
  u<=         : BitVec * BitVec => Bool (infix 70)    ;
  u>=         : BitVec * BitVec => Bool (infix 70)    ;
  u<          : BitVec * BitVec => Bool (infix 70)    ;
  u>          : BitVec * BitVec => Bool (infix 70)    ;

  ~           : BitVec => BitVec;
  &           : BitVec * BitVec => BitVec (l-infix 150) ;
  |           : BitVec * BitVec => BitVec (l-infix 100) ;
  ^           : BitVec * BitVec => BitVec (l-infix 100) ;

  neg         : BitVec => BitVec;
  +i          : BitVec * BitVec => BitVec (l-infix 100);
  -i          : BitVec * BitVec => BitVec (l-infix 100);
  <<          : BitVec * BitVec => BitVec (r-infix 100);

  #x0: BitVec;
  #x1: BitVec;
  #xff: BitVec;

  absbv : BitVec => BitVec ;
  ashr_th : BitVec * BitVec => BitVec;
  computeKnownZeroBits : BitVec => BitVec;
  countLeadingZeros : BitVec => BitVec;
  countTrailingZeros : BitVec => BitVec;
  hasOneUse : Bool;
  isPowerOf2 : BitVec => Bool;
  isPowerOf2OrZero : BitVec => Bool;
  isShiftedMask : BitVec => Bool;
  isSignBit : BitVec => Bool;
  lshr_th : BitVec * BitVec => BitVec;
  log2 : BitVec => BitVec;
  MaskedValueIsZero : BitVec * BitVec => Bool;
  sext : BitVec => BitVec;
  sext_i1 : BitVec => BitVec;
  trunc : BitVec => BitVec;
  umax : BitVec * BitVec => BitVec;
  width : BitVec => BitVec;
  WillNotOverflowSignedAdd : BitVec * BitVec => Bool;
  WillNotOverflowSignedSub : BitVec * BitVec => Bool;
  WillNotOverflowUnsignedAdd : BitVec * BitVec => Bool;
  WillNotOverflowUnsignedSub : BitVec * BitVec => Bool;
  zext_i1 : BitVec => BitVec;

SMT-RENAMINGS
  i< 		-> bvslt;
  i<=  	-> bvsle;
  i> 		-> bvsgt;
  i>=  	-> bvsge;
  u< 		-> bvult;
  u<=  	-> bvule;
  u> 		-> bvugt;
  u>=  	-> bvuge;

  +i 		-> bvadd;
  -i  	-> bvsub;

  ~  	-> bvnot;
  &  	-> bvand;
  |  	-> bvor;

SMT-TRANSLATIONS
  !=(x, y) -> (not (= x y));
  absbv(x,y) -> (ite (bvsgt x y) x y);    /* FIXME: is this really supposed to be signed? */
  ashr_th(x,y) -> (bvashr x y);           /* not in SMT-LIB but accepted by Z3 */
  computeKnownZeroBits(x) -> (bvadd #x0 #x0);         /* FIXME: how to do better? */
  countLeadingZeros(x) -> (+ 0 0);              /* FIXME: how to do better? */
  countTrailingZeros(x) -> (+ 0 0);             /* FIXME: how to do better? */
  isPowerOf2(x) -> (and (= (bvand x (bvsub x #x1)) #x0) (not (= x #x0))) ;
  isPowerOf2OrZero(x) -> (= (bvand x (bvsub x #x1)) #x0);
  isShiftedMask(x) -> (= x x);              /* FIXME: how to write true or do better? */
  isSignBit(x) -> (= 1 (sign x));
  log2(x) -> (ite (= x #x1) #x0 (ite (= x #x2) #x1 (ite (= x #x4) #x2 (ite (= x #x8) #x3 (ite (= x #x10) #x4 (ite (= x #20) #x5 (ite (= x #40) #x6 #x7)))))))
  lshr_th(x,y) -> (bvlshr x y);
  neg(x) -> (bvneg x) ;
  MaskedValueIsZero(x, m) -> (= (bvand x m) (nat2bv8 0));
  sign(x) -> (extract 7 7 x) ;
  WillNotOverflowSignedAdd(x,y) -> (not (and (= (sign x) #x0) (= (sign y) #x0) (= (sign (bvadd x y)) #x1) ) );
  WillNotOverflowSignedSub(x,y) -> (not (and (= (sign x) #x1) (= (sign y) #x0) (= (sign (bvadd x y)) #x0) ) );
  WillNotOverflowUnsignedAdd(x,y) -> (not (and (or (= (sign x) #x1) (= (sign y) #x1)) (= (sign (bvadd x y)) #x0) ) );
  WillNotOverflowUnsignedSub(x,y) -> (not (and (or (= (sign x) #x0) (= (sign y) #x1)) (= (sign (bvadd x y)) #x1) ) );
  sext(x) -> x ; /* FIXME: how to deal with bitvectors of different sizes? */
  sext_i1(x) -> x ; /* FIXME: how to deal with bitvectors of different sizes? */
  zext_i1(x) -> x ; /* FIXME: how to deal with bitvectors of different sizes? */
  trunc(x) -> x ; /* FIXME: how to deal with bitvectors of different sizes? */
  width(x) -> #x8; /* FIXME: how to deal with bitvectors of different sizes? */
